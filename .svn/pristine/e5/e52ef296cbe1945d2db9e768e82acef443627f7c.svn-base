/*
	key:CTRL组合, ~~~ 尽量简单
	注意替换原有功能

	CTRL + ↑: 1.搜索结果中同文件选择;2.选择函数名，返回调用位置;3.其他情况同原功能
	CTRL + ↓: 1.搜索结果中同文件选择;2.其他情况同原功能
	CTRL + ←: 1.搜索结果中不处理;2.原功能
	CTRL + →: 1.搜索结果中不处理;2.原功能
 
	ctrl + W: 1.修改原功能, 不关闭搜索结果窗口, 但会删除一半内容
	ctrl + Q: 1.打开下一个窗口
	ctrl + T: 1.交换true/false

    
	ctrl + D: 1. 妖键, 代码简用 SR，上下选；删除;
	          2. 添加行+宏；+=TRUE;=空格=上;
	          3. 非SR，向上向下查找复制内容;
	          3. 选择+对齐;
	          4. 选择1整行+ 设置对齐默认值;ctrl+D--sr--up,down;ctrl+D--mk--search copy
	          3. 选中，注释     对齐
	ctrl + B: 1.霸键, 代码共用;2.临时文件,当前任务-子任务
	ctrl + E: 1.普键, 代码通用;2 F10---默认区域--如font -- 每个文件1个默认行
	          3.base-F1/F2/../F12/E 打开文件或右侧project窗口
	          4.最后一次使用的F1
	ctrl + U: 1.术键, 代码任用    
	ctrl + N: 1.人键, 代码独用    
	ctrl + K: 1.魔键, 代码化用、 删除重复保留区别					    【未实现】
	
    
	原功能：
	ctrl + L: 也可以回到SI
	
	其他：
	ctrl + F12: 事件测试，或者其他测试, 详细说明在 aEvent.em中

//macro _TempHeadCTRL(hbuf){}
CtrlD()
CtrlQ()
CtrlB()
CtrlE()
CtrlW()
CtrlT()

CtrlUp()
CtrlDown()
CtrlLeft()
CtrlRight()
ChangeSel(hbuf, direct)

**/

/***********************************************************************/
/****************************    Mathod   ******************************/
/***********************************************************************/
macro CtrlD()
{
	//_TempHeadCTRL()
    hbuf = GetCurrentBuf()
	hwnd = GetCurrentWnd()
	if (hwnd == 0)
		stop
	
	sel = MGetWndSel(hbuf)
	if (!IsMoreSelect(sel))
	{
	    ret = CtrlUpAndDown(hbuf)
	    if(!ret)
	    {
	    	SearchForwardClip(hbuf)
	    }
	    if(!ret)
	    {
	    	SearchBackwardClip(hbuf)
	    }
	}
	else
	{
		lnMax = sel.lnLast
		while (lnMax >= sel.lnFirst)
		{
			DelBufLine(hbuf, lnMax)
			lnMax = lnMax - 1
		}
	}
}
macro CtrlB()
{
	//_TempHeadCTRL()
	OpenExistFile(getNodePath(0) # "\\Simple_CTRL_B.h")
}
macro CtrlE()
{
	//_TempHeadCTRL()
	Open
    /*
    hbuf = GetCurrentBuf()
    if(IsSRFile(hbuf))
	{
		mode = ReadMode(getLastCommandRow(0))
	 	if(mode == "CtrlE")
		{
			SaveMode(getLastCommandRow(0), "Ctrl")
			open_project
		}
		else
		{
			SaveMode(getLastCommandRow(0), "CtrlE")
		}
	}
	else
	{
		SaveMode(getLastCommandRow(0), "CtrlE")
		Open
	}*/
}
macro CtrlT()
{
    //交换true/false
	hwnd = GetCurrentWnd()
	hbuf = GetCurrentBuf()
	if (hwnd == 0)
	{
    	hbuf = OpenDefaultSR(hbuf)
    	stop
	}
	
	sel = MGetWndSel(hbuf)
	cur_line = GetBufLine(hbuf, sel.lnFirst )
	mar = GetLineMacro(cur_line)
	val = GetLineValue(cur_line)
	index = FindString( cur_line, val )
	len = strlen(cur_line)
	if(val == "TRUE")
	{
		reVal = "FALSE"
		strNew = strmid(cur_line,0,index) # reVal # strmid(cur_line, index+strlen(val), strlen(cur_line))
		PutBufLine(hbuf, sel.lnFirst, strNew);
	}
	else if(val == "FALSE")
	{
		reVal = "TRUE"
		strNew = strmid(cur_line,0,index) # reVal # strmid(cur_line, index+strlen(val), strlen(cur_line))
		PutBufLine(hbuf, sel.lnFirst, strNew);
	}
	else
	{
		//在末尾加和 = TRUE
		strNew = cur_line # "    = TRUE"
		PutBufLine(hbuf, sel.lnFirst, strNew);
	}
}
macro CtrlR()
{
	//_TempHeadCTRL()
	go_to_next_link
}
macro CtrlW()
{
	//_TempHeadCTRL()
    hbuf = GetCurrentBuf()
    hwnd = GetCurrentWnd()
	if (hwnd == 0)
		stop
	if(!IsSRFile(hbuf))
	{
		CloseWnd(hwnd)
	}else
	{
		count = GetBufLineCount(hbuf)
		if(count>40)
		{
			ln = count / 2 - 1
			if(ln<0)
				ln = 0
			while(ln>=0)
			{
				DelBufLine(hbuf, ln)
				ln = ln - 1
			}
			SaveBuf(hbuf)
		}
	}
	SaveMode(getLastCommandRow(0), "CtrlW")
}
macro CtrlQ()
{
	//_TempHeadCTRL()
	//打开下一个窗口
	hwnd = GetCurrentWnd()
	if (hwnd == 0)
		stop
	hwndNext = GetNextWnd(hwnd)
	if (hwndNext == 0)
		stop
	hbuf = GetWndBuf(hwndNext)
	SetCurrentBuf(hbuf)
}
/***********************************************************************/
/****************************    Direct   ******************************/
/***********************************************************************/
macro CtrlUpAndDown(hbuf)
{
	//_TempHeadCTRL()
	if(IsSRFile(hbuf))
	{
		ChangeSel(hbuf, 4)
		ChangeSel(hbuf, 5)
		return 1
	}else{
		return 0
	}
}
macro CtrlUp()
{
	//_TempHeadCTRL()
    hbuf = GetCurrentBuf()
	if(IsSRFile(hbuf))
	{
		ChangeSel(hbuf, 1)
	}
	else
	{
		//不选整行
		sel = MGetWndSel(hbuf)
		if(IsNoRowSelect(sel))
		{
			Jump_To_Caller
		}
		else
		{
			Drag_Line_Up
		}
	}
}
macro CtrlDown()
{
	//_TempHeadCTRL()
    hbuf = GetCurrentBuf()
	if(IsSRFile(hbuf))
	{
		ChangeSel(hbuf, 3)
	}
	else
	{
		Drag_Line_Down
	}
}
macro CtrlLeft()
{
	//_TempHeadCTRL()
    hbuf = GetCurrentBuf()
	if(IsSRFile(hbuf))
	{
		ChangeSel(hbuf, 0)
	}
	else
	{
		Word_Left
	}
}
macro CtrlRight()
{
	//_TempHeadCTRL()
    hbuf = GetCurrentBuf()
	if(IsSRFile(hbuf))
	{
		ChangeSel(hbuf, 2)
	}
	else
	{
		Word_Right
	}
}

//direct = 0 left; 1 top; 2 right; 3 down; 4/5 up and down;
macro ChangeSel(hbuf, direct)
{
	var sel
	var mode
	var mode_len
	var cur_line
	var cur_sel
	var ln
	var lnMin
	var lnMax
	var diff

	hwnd = GetCurrentWnd()
	if (hwnd == 0)
		stop
	
	//设置遍历范围
	sel = MGetWndSel(hbuf)
	if(direct==1 || direct==4)//top
	{
		lnMin =  sel.lnFirst - 1
		lnMax = 0
		diff = -1
		if(lnMin < 0)
		{
			stop
		}
	}
	else if(direct==3 || direct==5)//down
	{
		lnMin =  sel.lnLast + 1
		lnMax = GetBufLineCount(hbuf)
		diff = 1
		if(lnMin > lnMax - 1)
		{
			stop
		}
	}
	else
	{
		stop
	}
	
	if (IsSingleSelect(sel))
	{
		if(direct==4||direct==5)//Up And Down
		{
			//选择一行，添加参数
			cur_line = GetBufLine(hbuf, lnMin - diff)
		}
		else
		{
			//选择一行，添加参数
			cur_line = GetBufLine(hbuf, lnMin)
		}
		
		//获取行首单词
		mode = GetLineMacro(cur_line)
		mode_len = strlen(mode)
		if(mode_len > sel.ichLim)
		{
			//设置当前选择，更短
			mode = strmid(cur_line, sel.ichFirst, sel.ichLim)
			mode_len = strlen(mode)
		}
		SaveMode(getSRTmpRow(0), "@mode@")
	}
	else if (IsMoreSelect(sel))
	{
		if(direct==4)//Up And Down
		{
			stop
		}
		//选择多行，获取参数
		mode = ReadMode(getSRTmpRow(0))
		mode_len = strlen(mode)
		
		cur_line = GetBufLine(hbuf, lnMin)
		ret = LFindStringExt(cur_line, mode , mode_len)
		//msg ("Find @ret@   @cur_line@  @mode@ ")
		if(ret == "X")
		{
			if(direct==5)//Up And Down
			{
				stop
			}
			//获取行首单词
			mode = GetLineMacro(cur_line)
			mode_len = strlen(mode)
			SaveMode(getSRTmpRow(0), "@mode@")
		}
	}
	else
	{
		//不选择多行，获取首单词
		cur_line = GetBufLine(hbuf, sel.lnFirst)
		mode = GetLineMacro(cur_line)
		mode_len = strlen(mode)
		SaveMode(getSRTmpRow(0), "@mode@")
		
		sel.ichFirst = 0
		sel.ichLim = mode_len
		SetWndSel(hwnd, sel)
		stop
	}
	//msg ("mode @mode@ ")

	
	cur_line = ""
	ln =  lnMin
	//改变选择区域
	while (ln != lnMax)
	{
		cur_line = GetBufLine(hbuf, ln)
		ret = LFindStringExt(cur_line, mode, mode_len)
		//msg ("find @ret@  @mode@  ln @ln@  lnMax @lnMax@  @cur_line@ ")
		if(ret == "X")
		{
			break
		}
		ln =  ln + diff
	}
	ln =  ln - diff


	//多行选中，屏幕居中，行跳转
	hwnd = GetCurrentWnd()
	if (hwnd == 0)
		stop
	lnTop = GetWndVertScroll(hwnd);
	cLines = GetWndLineCount(hwnd);
	
	if(direct==1 || direct==4)//top
	{
		sel.lnFirst = ln
		sel.ichFirst = 0
		sel.lnLast = sel.lnLast 
		cur_line = GetBufLine(hbuf, sel.lnLast)
		sel.ichLim = strlen(cur_line)
		if (lnTop > ln)
		{
			if (ln > 10)
			{
				ln = ln - 10
			}
			ScrollWndToLine(hwnd, ln); 
		}
	}
	else if(direct==3 || direct==5)//down
	{
		//sel.lnFirst = sel.lnFirst
		sel.ichFirst = 0
		sel.lnLast = ln
		cur_line = GetBufLine(hbuf, sel.lnLast)
		sel.ichLim = strlen(cur_line)
		if (lnTop + cLines <= ln)
		{
			lnTop = ln - cLines + 1;
			if (lnTop + 10 < lnMax)
			{
				lnTop = lnTop + 10
			}
			ScrollWndToLine(hwnd, lnTop); 
		}
	}
	else
	{
		stop
	}
	SetWndSel(hwnd, sel)
}
/***********************************************************************/
/****************************    test   ******************************/
/***********************************************************************/
macro CtrlTest(hbuf)
{
	//msg ("CtrlTest")
	
    hbuf = GetCurrentBuf()
	ChangeSel(hbuf, 3)

	//SaveMode(getSRTmpRow(0), "@mode@")
	//mode = "m15"
	//SaveMode(15, "@mode@")
	//mode = ReadMode(getSRTmpRow(0))
	//msg ("mode15 @mode@ ")
	
	
	//msg ("CtrlTest")
	//Tree()
	//Drag_Line_Up
	//Drag_Line_Down
	//Word_Left
	
}
